// time - O(m+n), space - O(1)

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        // p1 → pointer for the last valid element in nums1 (index m-1)
        // p2 → pointer for the last element in nums2 (index n-1)
        // i  → pointer for the last index of nums1 (size = m+n)
        int p1 = m - 1, p2 = n - 1, i = m + n - 1;

        // Traverse from the back of both arrays
        while (p2 >= 0) { // only need to check p2, because nums1 already has its elements
            // If p1 is valid and nums1[p1] is bigger, place nums1[p1] at position i
            if (p1 >= 0 && nums1[p1] > nums2[p2]) {
                nums1[i--] = nums1[p1--];
            }
            // Otherwise, place nums2[p2] at position i
            else {
                nums1[i--] = nums2[p2--];
            }
        }
    }
};


/*
Example:
nums1 = [1, 2, 3, 0, 0, 0], m = 3
nums2 = [2, 5, 6], n = 3

Initial pointers:
p1 = m - 1 = 2 → pointing to 3
p2 = n - 1 = 2 → pointing to 6
i = m + n - 1 = 5 → last index in nums1

Iteration 1:
Compare nums1[p1] = 3 and nums2[p2] = 6
6 > 3 → put 6 at nums1[i]
nums1 = [1, 2, 3, 0, 0, 6]
Update: p2 = 1, i = 4

Iteration 2:
Compare nums1[p1] = 3 and nums2[p2] = 5
5 > 3 → put 5 at nums1[i]
nums1 = [1, 2, 3, 0, 5, 6]
Update: p2 = 0, i = 3

Iteration 3:
Compare nums1[p1] = 3 and nums2[p2] = 2
3 > 2 → put 3 at nums1[i]
nums1 = [1, 2, 3, 3, 5, 6]
Update: p1 = 1, i = 2

Iteration 4:
Compare nums1[p1] = 2 and nums2[p2] = 2
Since not greater, else executes → put 2 from nums2
nums1 = [1, 2, 2, 3, 5, 6]
Update: p2 = -1, i = 1

Loop ends (p2 < 0).
✅ Final merged array:

[1, 2, 2, 3, 5, 6]
*/
