class Solution {
public:
    vector<string> result; // To store all valid paths from (0,0) to (n-1,n-1)

    // Utility function to check if the current cell (i, j) is inside the grid
    bool isSafe(int i, int j, int n) {
        return i >= 0 && i < n && j >= 0 && j < n;
    }

    // Recursive backtracking function to explore paths
    void solve(int i, int j, vector<vector<int>> &m, int n, string& temp) {
        // If out of bounds OR cell is blocked (0), return
        if (!isSafe(i, j, n) || m[i][j] == 0) {
            return;
        }

        // If we reached the destination cell (bottom-right corner)
        if (i == n - 1 && j == n - 1) {
            result.push_back(temp); // Store the current path
            return;
        }

        // Mark current cell as visited (set 0 so we don't revisit)
        m[i][j] = 0;

        // Move Down
        temp.push_back('D');
        solve(i + 1, j, m, n, temp);
        temp.pop_back(); // backtrack

        // Move Right
        temp.push_back('R');
        solve(i, j + 1, m, n, temp);
        temp.pop_back();

        // Move Up
        temp.push_back('U');
        solve(i - 1, j, m, n, temp);
        temp.pop_back();

        // Move Left
        temp.push_back('L');
        solve(i, j - 1, m, n, temp);
        temp.pop_back();

        // Unmark current cell (backtrack so it can be used in another path)
        m[i][j] = 1;
    }

    // Main function that finds all paths
    vector<string> findPath(vector<vector<int>> &m, int n) {
        string temp = ""; // To store current path sequence
        solve(0, 0, m, n, temp); // Start from (0,0)
        return result; // Return all paths found
    }
};
